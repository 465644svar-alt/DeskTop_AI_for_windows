# НАЗНАЧЕНИЕ ФАЙЛА: Вспомогательные утилиты общего назначения для приложения.
"""
Helper utilities for AI Manager
- Token counting and estimation
- Text processing
"""

import re  # ПОЯСНЕНИЕ: импортируется модуль re.
import logging  # ПОЯСНЕНИЕ: импортируется модуль logging.
from typing import List, Dict, Optional  # ПОЯСНЕНИЕ: импортируются внешние зависимости для работы модуля.

logger = logging.getLogger(__name__)  # ПОЯСНЕНИЕ: обновляется значение переменной logger.

# Try to import tiktoken for accurate token counting
# ЛОГИЧЕСКИЙ БЛОК: обработка ошибок и устойчивость выполнения.
try:  # ПОЯСНЕНИЕ: начинается блок перехвата возможных ошибок.
    import tiktoken  # ПОЯСНЕНИЕ: импортируется модуль tiktoken.
    TIKTOKEN_AVAILABLE = True  # ПОЯСНЕНИЕ: обновляется значение переменной TIKTOKEN_AVAILABLE.
# ЛОГИЧЕСКИЙ БЛОК: обработка ошибок и устойчивость выполнения.
except ImportError:  # ПОЯСНЕНИЕ: обрабатывается ошибка в блоке except.
    TIKTOKEN_AVAILABLE = False  # ПОЯСНЕНИЕ: обновляется значение переменной TIKTOKEN_AVAILABLE.
    logger.info("tiktoken not available, using estimation")  # ПОЯСНЕНИЕ: выполняется текущая инструкция этого шага логики.


# ЛОГИЧЕСКИЙ БЛОК: класс `TokenCounter` — объединяет состояние и поведение подсистемы.
class TokenCounter:  # ПОЯСНЕНИЕ: объявляется класс TokenCounter.
    """Token counter with tiktoken or estimation fallback"""  # ПОЯСНЕНИЕ: задается или продолжается строка документации.

    # Average chars per token for different languages
    CHARS_PER_TOKEN = {  # ПОЯСНЕНИЕ: обновляется значение переменной CHARS_PER_TOKEN.
        "english": 4.0,  # ПОЯСНЕНИЕ: выполняется текущая инструкция этого шага логики.
        "code": 3.5,  # ПОЯСНЕНИЕ: выполняется текущая инструкция этого шага логики.
        "mixed": 3.0,  # ПОЯСНЕНИЕ: выполняется текущая инструкция этого шага логики.
        "russian": 2.0,  # Cyrillic uses more tokens  # ПОЯСНЕНИЕ: выполняется текущая инструкция этого шага логики.
        "chinese": 1.5  # ПОЯСНЕНИЕ: выполняется текущая инструкция этого шага логики.
    }  # ПОЯСНЕНИЕ: выполняется текущая инструкция этого шага логики.

    # ЛОГИЧЕСКИЙ БЛОК: функция `__init__` — выполняет отдельный шаг бизнес-логики.
    def __init__(self, model: str = "gpt-4"):  # ПОЯСНЕНИЕ: объявляется функция __init__ с параметрами из сигнатуры.
        """Описание: функция `__init__`."""  # ПОЯСНЕНИЕ: задается или продолжается строка документации.
        self.model = model  # ПОЯСНЕНИЕ: обновляется значение переменной self.model.
        self._encoder = None  # ПОЯСНЕНИЕ: обновляется значение переменной self._encoder.

        # ЛОГИЧЕСКИЙ БЛОК: ветвление условий для выбора дальнейшего сценария.
        if TIKTOKEN_AVAILABLE:  # ПОЯСНЕНИЕ: проверяется условие ветвления if.
            # ЛОГИЧЕСКИЙ БЛОК: обработка ошибок и устойчивость выполнения.
            try:  # ПОЯСНЕНИЕ: начинается блок перехвата возможных ошибок.
                self._encoder = tiktoken.encoding_for_model(model)  # ПОЯСНЕНИЕ: обновляется значение переменной self._encoder.
            # ЛОГИЧЕСКИЙ БЛОК: обработка ошибок и устойчивость выполнения.
            except KeyError:  # ПОЯСНЕНИЕ: обрабатывается ошибка в блоке except.
                # ЛОГИЧЕСКИЙ БЛОК: обработка ошибок и устойчивость выполнения.
                try:  # ПОЯСНЕНИЕ: начинается блок перехвата возможных ошибок.
                    self._encoder = tiktoken.get_encoding("cl100k_base")  # ПОЯСНЕНИЕ: обновляется значение переменной self._encoder.
                # ЛОГИЧЕСКИЙ БЛОК: обработка ошибок и устойчивость выполнения.
                except Exception:  # ПОЯСНЕНИЕ: обрабатывается ошибка в блоке except.
                    pass  # ПОЯСНЕНИЕ: оставляется пустая заглушка без действий.

    # ЛОГИЧЕСКИЙ БЛОК: функция `count_tokens` — выполняет отдельный шаг бизнес-логики.
    def count_tokens(self, text: str) -> int:  # ПОЯСНЕНИЕ: объявляется функция count_tokens с параметрами из сигнатуры.
        """Count tokens in text"""  # ПОЯСНЕНИЕ: задается или продолжается строка документации.
        # ЛОГИЧЕСКИЙ БЛОК: ветвление условий для выбора дальнейшего сценария.
        if self._encoder:  # ПОЯСНЕНИЕ: проверяется условие ветвления if.
            # ЛОГИЧЕСКИЙ БЛОК: обработка ошибок и устойчивость выполнения.
            try:  # ПОЯСНЕНИЕ: начинается блок перехвата возможных ошибок.
                return len(self._encoder.encode(text))  # ПОЯСНЕНИЕ: возвращается результат из текущей функции.
            # ЛОГИЧЕСКИЙ БЛОК: обработка ошибок и устойчивость выполнения.
            except Exception:  # ПОЯСНЕНИЕ: обрабатывается ошибка в блоке except.
                pass  # ПОЯСНЕНИЕ: оставляется пустая заглушка без действий.
        return self._estimate_tokens(text)  # ПОЯСНЕНИЕ: возвращается результат из текущей функции.

    # ЛОГИЧЕСКИЙ БЛОК: функция `_estimate_tokens` — выполняет отдельный шаг бизнес-логики.
    def _estimate_tokens(self, text: str) -> int:  # ПОЯСНЕНИЕ: объявляется функция _estimate_tokens с параметрами из сигнатуры.
        """Estimate token count based on character analysis"""  # ПОЯСНЕНИЕ: задается или продолжается строка документации.
        # ЛОГИЧЕСКИЙ БЛОК: ветвление условий для выбора дальнейшего сценария.
        if not text:  # ПОЯСНЕНИЕ: проверяется условие ветвления if.
            return 0  # ПОЯСНЕНИЕ: возвращается результат из текущей функции.

        # Detect language/content type
        cyrillic_ratio = len(re.findall(r'[а-яА-ЯёЁ]', text)) / max(len(text), 1)  # ПОЯСНЕНИЕ: обновляется значение переменной cyrillic_ratio.
        code_ratio = len(re.findall(r'[{}()\[\];=<>]', text)) / max(len(text), 1)  # ПОЯСНЕНИЕ: обновляется значение переменной code_ratio.

        # ЛОГИЧЕСКИЙ БЛОК: ветвление условий для выбора дальнейшего сценария.
        if cyrillic_ratio > 0.3:  # ПОЯСНЕНИЕ: проверяется условие ветвления if.
            chars_per_token = self.CHARS_PER_TOKEN["russian"]  # ПОЯСНЕНИЕ: обновляется значение переменной chars_per_token.
        # ЛОГИЧЕСКИЙ БЛОК: ветвление условий для выбора дальнейшего сценария.
        elif code_ratio > 0.1:  # ПОЯСНЕНИЕ: проверяется дополнительное условие elif.
            chars_per_token = self.CHARS_PER_TOKEN["code"]  # ПОЯСНЕНИЕ: обновляется значение переменной chars_per_token.
        # ЛОГИЧЕСКИЙ БЛОК: ветвление условий для выбора дальнейшего сценария.
        else:  # ПОЯСНЕНИЕ: выполняется альтернативная ветка else.
            chars_per_token = self.CHARS_PER_TOKEN["mixed"]  # ПОЯСНЕНИЕ: обновляется значение переменной chars_per_token.

        return int(len(text) / chars_per_token) + 1  # ПОЯСНЕНИЕ: возвращается результат из текущей функции.

    # ЛОГИЧЕСКИЙ БЛОК: функция `count_messages_tokens` — выполняет отдельный шаг бизнес-логики.
    def count_messages_tokens(self, messages: List[Dict[str, str]]) -> int:  # ПОЯСНЕНИЕ: объявляется функция count_messages_tokens с параметрами из сигнатуры.
        """Count total tokens in a list of messages"""  # ПОЯСНЕНИЕ: задается или продолжается строка документации.
        total = 0  # ПОЯСНЕНИЕ: обновляется значение переменной total.
        # ЛОГИЧЕСКИЙ БЛОК: цикл для поэтапной обработки данных.
        for msg in messages:  # ПОЯСНЕНИЕ: запускается цикл for по коллекции.
            # Add overhead for message structure (~4 tokens per message)
            total += 4  # ПОЯСНЕНИЕ: обновляется значение переменной total +.
            content = msg.get("content", "")  # ПОЯСНЕНИЕ: обновляется значение переменной content.
            total += self.count_tokens(content)  # ПОЯСНЕНИЕ: обновляется значение переменной total +.
        return total  # ПОЯСНЕНИЕ: возвращается результат из текущей функции.

    # ЛОГИЧЕСКИЙ БЛОК: функция `trim_messages_by_tokens` — выполняет отдельный шаг бизнес-логики.
    def trim_messages_by_tokens(  # ПОЯСНЕНИЕ: объявляется функция trim_messages_by_tokens с параметрами из сигнатуры.
        self,  # ПОЯСНЕНИЕ: выполняется текущая инструкция этого шага логики.
        messages: List[Dict[str, str]],  # ПОЯСНЕНИЕ: выполняется текущая инструкция этого шага логики.
        max_tokens: int,  # ПОЯСНЕНИЕ: выполняется текущая инструкция этого шага логики.
        keep_system: bool = True  # ПОЯСНЕНИЕ: обновляется значение переменной keep_system: bool.
    ) -> List[Dict[str, str]]:  # ПОЯСНЕНИЕ: начинается новый логический блок кода.
        """Trim messages to fit within token limit"""  # ПОЯСНЕНИЕ: задается или продолжается строка документации.
        # ЛОГИЧЕСКИЙ БЛОК: ветвление условий для выбора дальнейшего сценария.
        if not messages:  # ПОЯСНЕНИЕ: проверяется условие ветвления if.
            return messages  # ПОЯСНЕНИЕ: возвращается результат из текущей функции.

        result = []  # ПОЯСНЕНИЕ: обновляется значение переменной result.
        current_tokens = 0  # ПОЯСНЕНИЕ: обновляется значение переменной current_tokens.

        # If keeping system message, add it first
        system_msg = None  # ПОЯСНЕНИЕ: обновляется значение переменной system_msg.
        other_messages = []  # ПОЯСНЕНИЕ: обновляется значение переменной other_messages.

        # ЛОГИЧЕСКИЙ БЛОК: цикл для поэтапной обработки данных.
        for msg in messages:  # ПОЯСНЕНИЕ: запускается цикл for по коллекции.
            # ЛОГИЧЕСКИЙ БЛОК: ветвление условий для выбора дальнейшего сценария.
            if msg.get("role") == "system" and keep_system:  # ПОЯСНЕНИЕ: проверяется условие ветвления if.
                system_msg = msg  # ПОЯСНЕНИЕ: обновляется значение переменной system_msg.
            # ЛОГИЧЕСКИЙ БЛОК: ветвление условий для выбора дальнейшего сценария.
            else:  # ПОЯСНЕНИЕ: выполняется альтернативная ветка else.
                other_messages.append(msg)  # ПОЯСНЕНИЕ: выполняется текущая инструкция этого шага логики.

        # ЛОГИЧЕСКИЙ БЛОК: ветвление условий для выбора дальнейшего сценария.
        if system_msg:  # ПОЯСНЕНИЕ: проверяется условие ветвления if.
            system_tokens = self.count_tokens(system_msg.get("content", "")) + 4  # ПОЯСНЕНИЕ: обновляется значение переменной system_tokens.
            current_tokens += system_tokens  # ПОЯСНЕНИЕ: обновляется значение переменной current_tokens +.
            result.append(system_msg)  # ПОЯСНЕНИЕ: выполняется текущая инструкция этого шага логики.

        # Add messages from newest to oldest until limit
        # ЛОГИЧЕСКИЙ БЛОК: цикл для поэтапной обработки данных.
        for msg in reversed(other_messages):  # ПОЯСНЕНИЕ: запускается цикл for по коллекции.
            msg_tokens = self.count_tokens(msg.get("content", "")) + 4  # ПОЯСНЕНИЕ: обновляется значение переменной msg_tokens.
            # ЛОГИЧЕСКИЙ БЛОК: ветвление условий для выбора дальнейшего сценария.
            if current_tokens + msg_tokens <= max_tokens:  # ПОЯСНЕНИЕ: проверяется условие ветвления if.
                result.insert(1 if system_msg else 0, msg)  # ПОЯСНЕНИЕ: выполняется текущая инструкция этого шага логики.
                current_tokens += msg_tokens  # ПОЯСНЕНИЕ: обновляется значение переменной current_tokens +.
            # ЛОГИЧЕСКИЙ БЛОК: ветвление условий для выбора дальнейшего сценария.
            else:  # ПОЯСНЕНИЕ: выполняется альтернативная ветка else.
                break  # ПОЯСНЕНИЕ: цикл прерывается немедленно.

        # Ensure at least the last user message is included
        # ЛОГИЧЕСКИЙ БЛОК: ветвление условий для выбора дальнейшего сценария.
        if len(result) == (1 if system_msg else 0) and other_messages:  # ПОЯСНЕНИЕ: проверяется условие ветвления if.
            result.append(other_messages[-1])  # ПОЯСНЕНИЕ: выполняется текущая инструкция этого шага логики.

        return result  # ПОЯСНЕНИЕ: возвращается результат из текущей функции.


# ЛОГИЧЕСКИЙ БЛОК: функция `estimate_tokens` — выполняет отдельный шаг бизнес-логики.
def estimate_tokens(text: str) -> int:  # ПОЯСНЕНИЕ: объявляется функция estimate_tokens с параметрами из сигнатуры.
    """Quick token estimation without creating TokenCounter"""  # ПОЯСНЕНИЕ: задается или продолжается строка документации.
    # ЛОГИЧЕСКИЙ БЛОК: ветвление условий для выбора дальнейшего сценария.
    if not text:  # ПОЯСНЕНИЕ: проверяется условие ветвления if.
        return 0  # ПОЯСНЕНИЕ: возвращается результат из текущей функции.

    # Simple estimation: ~4 chars per token for English, ~2 for Cyrillic
    cyrillic_count = len(re.findall(r'[а-яА-ЯёЁ]', text))  # ПОЯСНЕНИЕ: обновляется значение переменной cyrillic_count.
    other_count = len(text) - cyrillic_count  # ПОЯСНЕНИЕ: обновляется значение переменной other_count.

    return int(cyrillic_count / 2 + other_count / 4) + 1  # ПОЯСНЕНИЕ: возвращается результат из текущей функции.


# ЛОГИЧЕСКИЙ БЛОК: функция `truncate_text` — выполняет отдельный шаг бизнес-логики.
def truncate_text(text: str, max_chars: int = 500, suffix: str = "...") -> str:  # ПОЯСНЕНИЕ: объявляется функция truncate_text с параметрами из сигнатуры.
    """Truncate text to max characters"""  # ПОЯСНЕНИЕ: задается или продолжается строка документации.
    # ЛОГИЧЕСКИЙ БЛОК: ветвление условий для выбора дальнейшего сценария.
    if len(text) <= max_chars:  # ПОЯСНЕНИЕ: проверяется условие ветвления if.
        return text  # ПОЯСНЕНИЕ: возвращается результат из текущей функции.
    return text[:max_chars - len(suffix)] + suffix  # ПОЯСНЕНИЕ: возвращается результат из текущей функции.


# ЛОГИЧЕСКИЙ БЛОК: функция `format_elapsed_time` — выполняет отдельный шаг бизнес-логики.
def format_elapsed_time(seconds: float) -> str:  # ПОЯСНЕНИЕ: объявляется функция format_elapsed_time с параметрами из сигнатуры.
    """Format elapsed time nicely"""  # ПОЯСНЕНИЕ: задается или продолжается строка документации.
    # ЛОГИЧЕСКИЙ БЛОК: ветвление условий для выбора дальнейшего сценария.
    if seconds < 1:  # ПОЯСНЕНИЕ: проверяется условие ветвления if.
        return f"{seconds*1000:.0f}ms"  # ПОЯСНЕНИЕ: возвращается результат из текущей функции.
    # ЛОГИЧЕСКИЙ БЛОК: ветвление условий для выбора дальнейшего сценария.
    elif seconds < 60:  # ПОЯСНЕНИЕ: проверяется дополнительное условие elif.
        return f"{seconds:.1f}s"  # ПОЯСНЕНИЕ: возвращается результат из текущей функции.
    # ЛОГИЧЕСКИЙ БЛОК: ветвление условий для выбора дальнейшего сценария.
    else:  # ПОЯСНЕНИЕ: выполняется альтернативная ветка else.
        minutes = int(seconds // 60)  # ПОЯСНЕНИЕ: обновляется значение переменной minutes.
        secs = seconds % 60  # ПОЯСНЕНИЕ: обновляется значение переменной secs.
        return f"{minutes}m {secs:.0f}s"  # ПОЯСНЕНИЕ: возвращается результат из текущей функции.


# ЛОГИЧЕСКИЙ БЛОК: функция `sanitize_filename` — выполняет отдельный шаг бизнес-логики.
def sanitize_filename(name: str) -> str:  # ПОЯСНЕНИЕ: объявляется функция sanitize_filename с параметрами из сигнатуры.
    """Sanitize string for use as filename"""  # ПОЯСНЕНИЕ: задается или продолжается строка документации.
    # Remove invalid characters
    invalid_chars = '<>:"/\\|?*'  # ПОЯСНЕНИЕ: обновляется значение переменной invalid_chars.
    # ЛОГИЧЕСКИЙ БЛОК: цикл для поэтапной обработки данных.
    for char in invalid_chars:  # ПОЯСНЕНИЕ: запускается цикл for по коллекции.
        name = name.replace(char, '_')  # ПОЯСНЕНИЕ: обновляется значение переменной name.
    return name[:100]  # Limit length  # ПОЯСНЕНИЕ: возвращается результат из текущей функции.
